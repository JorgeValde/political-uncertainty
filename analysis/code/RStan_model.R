#*****************************************************************************************
#	PURPOSE OF THIS FILE: (description comes from original "Order of the files.docx" )
#		This is the R script we run. Differently from the previous model, 
#		we ask R to keep only every tenth of the iteration due to the size concerns.
#*****************************************************************************************

#*****************************************************************************************
# Load a few libraries 
#*****************************************************************************************
library(rstan)
library(coda)
library(ggmcmc)

# setting for rstan
# automatically save a compiled Stan program so not need to be recompiled 
rstan_options(auto_write = TRUE)  
# set core number in case of parallel computing needed
options(mc.cores = parallel::detectCores())

#*****************************************************************************************
# Set working dirctory to the folder source file in                                        
#*****************************************************************************************
# get the dirctory of this source file in order to use relative paths
source.dir <- dirname(sys.frame(1)$ofile)  # returns the path of the current script file
setwd(paste(source.dir))  # set current dir as the working dir 

#*****************************************************************************************
# Prepare data and code for stan
#*****************************************************************************************
# read data files (use relative path for general use in any computer)
votes<- read.csv("../../build/output/data_for_rstan.csv", header=TRUE)
attach(votes)
groups<- read.csv("../../build/output/group_dummy_for_rstan.csv", header=TRUE)

# MODEL WITH GROUP IND
votes_code<- "
## Stan code for multidimensional hierarchical IRT model
data {
  int<lower=1> J;              // number of legislators
  int<lower=1> K;              // number of votes
  int<lower=1> N;              // number of observations
  int<lower=1> G;              // number of groups
  int<lower=1,upper=J> jj[N];  // legislator for observation n
  int<lower=1,upper=K> kk[N];  // vote for observation n
  matrix[N,G] x;			   // group indicators
  int<lower=0,upper=1> y[N];   // position for observation n
//  vector[N] y;               // position for observation n
}

parameters {    
  matrix[J,G] alpha;               //  
  matrix[K,G] beta;                // 
  real mu_beta;
  real<lower=0> sigma_beta;
  matrix<lower=0>[K,G] gamma;
  real mu_gamma;
  real<lower=0> sigma_gamma;
}

transformed parameters { 
//  real total[N]; 
  vector[N] total; 

  { 
    matrix[N,G] summands; 
    for (g in 1:G) 
      for (n in 1:N) 
        summands[n,g]<- (x[n,g]*gamma[kk[n],g])*(alpha[jj[n],g] - beta[kk[n],g]); 

    for (n in 1:N) 
 //     for (g in 1:G) 
        total[n] <- sum(summands[n]); 
  } 
} 

model {
 to_vector(alpha) ~ normal(0,1);         
 
 to_vector(beta) ~ normal(mu_beta, sigma_beta);
 mu_beta~ normal(0, 3);
 sigma_beta ~ cauchy(0,3);
 
 to_vector(gamma) ~ lognormal(mu_gamma, sigma_gamma);
 mu_gamma ~ normal(0, 3);
 sigma_gamma ~ cauchy(0,3);
 
 y ~ bernoulli_logit(total);
}"

# assemble a list of data to fit the model, get all the values from the data
votes_dat <- list(
    N = nrow(votes),                        # number of observations
    J = max(votes$politician_id_numeric),   # number of legislators
    K = max(votes$action_id_numeric),       # number of votes
    G = ncol(groups),                       # number of groups
    jj = politician_id_numeric,             # legislator vector
    kk = action_id_numeric,                 # vote vector
    y = vote,                               # position vector
    x = as.matrix(groups)                   # group indicators
)

# call the stan function to draw posterior samples
fit6 <- stan(
    model_code = votes_code,                # Stan model
    data = votes_dat,                       # named list of data
    iter = 2000,                            # total number of iterations per chain
    warmup = 1000,                          # number of warmup iterations per chain
    chains = 4,                             # number of Markov chains
    seed = 1234,                            # set seed for replication
    verbose = TRUE,                         # print intemediate output from stan
    control = list(max_treedepth = 15)      # for warnings 2 below 
)

###*****************************************************************************************
## Warnings generated by Rstan after theWarning messages:
###*****************************************************************************************
## 1: There were 25 divergent transitions after warmup. Increasing adapt_delta above 0.8 may help. See
## http://mc-stan.org/misc/warnings.html#divergent-transitions-after-warmup 
## 2: There were 1975 transitions after warmup that exceeded the maximum treedepth. Increase max_treedepth above 10. See http://mc-stan.org/misc/warnings.html#maximum-treedepth-exceeded 
## 3: There were 2 chains where the estimated Bayesian Fraction of Missing Information was low. See
## http://mc-stan.org/misc/warnings.html#bfmi-low 
## 4: Examine the pairs() plot to diagnose sampling problems
###*****************************************************************************************

###*****************************************************************************************
## EXPORTING                                
###*****************************************************************************************
## save workplace for later analysis
save.image("../temp/32groups_2chains_2000iters.RData")

## exporting ideal points and match them with legislators
## extract out ideal points(alpha)
alpha_sum <- rstan::summary(fit6, pars = c("alpha"), probs = c(0.05, 0.95))$summary

## factor out politician names with id from votes
politician <- subset(votes, select = c("politician_id_numeric", "fullname"))
## get all the values of politician names and id only once
politician <- unique(politician[,1:2])
## sort this data by politician_id_numeric
politician <- politician[order(politician$politician_id_numeric),]

## add one column called groups to use expandRows() function
politician$groups <- ncol(groups)
## expand this data "number_of_groups" times to match alpha_sum
library(splitstackshape)
politician<- expandRows(politician, count = "groups")

## combine alpha_sum with politician names and ids
alpha_sum_names <- cbind(alpha_sum, politician[,1:2])
## export it to a csv file
write.csv(alpha_sum_names, file = "../output/alpha_with_names.csv", row.names = TRUE)

###*****************************************************************************************
### GRAPHING                                        
###*****************************************************************************************
# ggmcmc requires Tidyr, which has a naming overlap with extract, so call rstan::extract explicitly
#s <- rstan::extract(fit6, inc_warmup = FALSE)  
#s <- mcmc.list(lapply(1:ncol(fit6), function(x) mcmc(as.array(fit6)[,x,])))
#S <- ggs(s)
#library(foreign)
#write.dta(S, file = "../output/mcmc_output.dta")

### Rhat statistics
## The Rhat statistic measures the ratio of the average variance of samples within each chain to the variance of the pooled samples across chains; if all chains are at equilibrium, these will be the same and Rhat will be one. If the chains have not converged to a common distribution, the Rhat statistic will be greater than one. (Stan Development Team, 2016).
stan_rhat(fit6, bins=30)

### scatter graphs of legislators' ideal point and uncertainty(std. dev.)
num_groups <- ncol(groups)     # get the number of groups
## separate out OS_catcode with business
sector <- subset(votes, select = c("OS_catcode", "business"))
## get all pairs of OS_catcode with business only once
sector <- unique(sector[,1:2])

## get the OS_catcode of groups
OS_catcode_model <- colnames(groups)

for(i in 1:num_groups) {
    ## separate out group i
    alpha_group_i = alpha_sum_names[seq(from = i, to = nrow(alpha_sum_names), by = num_groups),]
    business_i <- sector[which(sector$OS_catcode == OS_catcode_model[i]),][1,]$business
    ## plot ideal points and uncertainty for this group
    print(ggplot(data = alpha_group_i, aes(x = mean, y = sd))
          + geom_point()
          + ggtitle(business_i)
          + scale_x_continuous(name="Legislators' Ideal Point")
          + scale_y_continuous(name="Uncertainty(Std. Dev.)"))
    ## generate file name with location and save as images
    name_group_i = paste(num_groups, "_groups_ideal_points_group_", i, ".png", sep = "")
    ggsave(name_group_i, path = "../output/") # save as images, alternative is pdf files
}

